# -*- coding: utf-8 -*-
"""Tubes ML Tyas Nur Kumala (1301213030).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_w9JElVYQv4sv82K7891Y_wDgE1qnSGP

**Tyas Nur Kumala (1301213030)**
1. Fungsi : F4
2. Range : [-20, 20]
2. Metode GWO dan ABC

[Link Youtube Presentasi](https://youtu.be/AnVY3pPLcTQ)

Import
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

"""Fungsi F4

"""

def F4(x):
    return np.max(np.abs(x))

"""
Fungsi F4 didefinisikan sebagai nilai maksimum dari nilai absolut dari koordinat input x. Dalam hal ini, x adalah vektor dua dimensi dengan komponen x1 dan x2.
Fungsi F4 dapat dinyatakan sebagai berikut:F4(x)=max(‚à£x1‚Äã‚à£,‚à£x2‚Äã‚à£)"""

# Define parameters
lb = -20  # lower bound
ub = 20   # upper bound

# Create a grid of points
x1 = np.arange(lb, ub + 1, 1)
x2 = np.arange(lb, ub + 1, 1)
x1, x2 = np.meshgrid(x1, x2)

# Compute the function values
z = np.zeros_like(x1)
for i in range(x1.shape[0]):
    for j in range(x1.shape[1]):
        z[i, j] = F4(np.array([x1[i, j], x2[i, j]]))

# Plot the surface
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(x1, x2, z, cmap='viridis')

ax.set_title('F4')
ax.set_xlabel('x1')
ax.set_ylabel('x2')
ax.set_zlabel('Fitness (x1, x2)')
plt.show()

"""1. Nilai Fungsi:
Nilai fungsi F4 dihitung untuk setiap titik pada grid.
Nilai z pada setiap titik grid adalah hasil dari fungsi F4 yang diterapkan pada koordinat (x1, x2).

2. Visualisasi Permukaan:
Plot permukaan tiga dimensi menampilkan nilai z (yaitu nilai F4) sebagai ketinggian permukaan.
Warna permukaan bervariasi dari kuning (nilai tinggi) hingga biru (nilai rendah).
Bentuk permukaan menarik karena terdapat cekungan di tengah dan naik tajam ke arah tepi, membentuk pit persegi.

Visualisasi ini membantu kita memahami bagaimana kombinasi x1 dan x2 dalam rentang [-20, 20] mempengaruhi ‚Äúkebugaran‚Äù (fitness) fungsi F4. Semakin besar nilai absolut dari x1 atau x2, semakin tinggi nilai fitnessnya.

**Visualisasi Solution Space**
"""

# Compute the function values
z = np.zeros_like(x1)
for i in range(x1.shape[0]):
    for j in range(x1.shape[1]):
        z[i, j] = F4(np.array([x1[i, j], x2[i, j]]))

# Define the best position found by GWO (for example, assume it is at [0, 0])
best_position = [0, 0]

# Plot the contour plot
plt.contourf(x1, x2, z, cmap='viridis', levels=50)
plt.colorbar(label='Fitness')
plt.title('Contour Plot of Solution Space')
plt.xlabel('x1')
plt.ylabel('x2')

# Plot the best solution found by GWO
plt.scatter(best_position[0], best_position[1], color='red', label='Best Solution')
plt.legend()

plt.show()

"""1. Plot Kontur:
Plot ini menampilkan ruang solusi dua dimensi.
Pada sumbu x, terdapat label x1 yang berkisar dari sekitar -20 hingga 20.
Pada sumbu y, terdapat label x2 dengan rentang yang serupa.
Garis kontur diisi dengan warna, mulai dari biru tua di tepi hingga kuning terang di tengah.
Warna mengindikasikan tingkat kebugaran (fitness) berdasarkan skala warna di sebelah kanan, yang berkisar dari 0 hingga sekitar 19,2.

2. Judul dan Titik Terbaik:
Judul plot adalah ‚ÄúContour Plot of Solution Space‚Äù.
Titik merah yang diberi label ‚ÄúBest Solution‚Äù menunjukkan posisi terbaik yang ditemukan oleh Algoritma Optimisasi Serigala Abu-abu (Grey Wolf Optimizer, GWO).
Dalam contoh ini, posisi terbaik berada pada koordinat [0, 0] di tengah plot, di mana dugaan solusi optimal berada, karena di area ini terdapat nilai kebugaran tertinggi berdasarkan intensitas warna.

Visualisasi ini membantu kita memahami bagaimana solusi-solusi didistribusikan dalam ruang dan di mana solusi optimal mungkin berada untuk masalah optimisasi.

**GWO**

Grey Wolf Optimization (GWO) adalah algoritma optimisasi yang terinspirasi oleh perilaku serigala abu-abu dalam mencari mangsa. Algoritma ini menggabungkan konsep gerakan serigala dalam kawanan untuk mencari solusi optimal dalam ruang pencarian. Berikut adalah beberapa poin penting tentang GWO:

Parameter:

- Jumlah Serigala (num_wolves): 7
- Iterasi (num_iterations): 80
- Rentang Solusi (Range): [-20, 20]
- Interval: 300 milidetik
- FPS (Frame Per Second): 15

Dengan parameter-parameter ini, kita akan mengimplementasikan dan memvisualisasikan bagaimana serigala-serigala tersebut menyesuaikan posisi mereka dalam ruang pencarian untuk fungsi
ùêπ
4
(
ùë•
)
=
max
‚Å°
(
‚à£
ùë•
1
‚à£
,
‚à£
ùë•
2
‚à£
)
F4(x)=max(‚à£x
1
‚Äã
 ‚à£,‚à£x
2
‚Äã
 ‚à£).
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Define the F4 function
def F4(x):
    return np.max(np.abs(x))

# Define parameters
lb = -20  # lower bound
ub = 20   # upper bound
dim = 2   # dimension

# GWO parameters
num_wolves = 7
num_iterations = 80

# Initialize wolves' positions
wolves_pos = lb + (ub - lb) * np.random.rand(num_wolves, dim)

# Initialize alpha, beta, and delta wolves
alpha_pos = np.zeros(dim)
beta_pos = np.zeros(dim)
delta_pos = np.zeros(dim)

alpha_score = float('inf')
beta_score = float('inf')
delta_score = float('inf')

# Initialize plot
fig, ax = plt.subplots()
ax.set_xlim((lb, ub))
ax.set_ylim((lb, ub))

# Create a grid of points
x1 = np.arange(lb, ub + 1, 1)
x2 = np.arange(lb, ub + 1, 1)
x1, x2 = np.meshgrid(x1, x2)
z = np.zeros_like(x1)
for i in range(x1.shape[0]):
    for j in range(x1.shape[1]):
        z[i, j] = F4(np.array([x1[i, j], x2[i, j]]))

contour = ax.contourf(x1, x2, z, levels=50, cmap='viridis')
cbar = fig.colorbar(contour)

wolves_scatter = ax.scatter(wolves_pos[:, 0], wolves_pos[:, 1], color='red', marker='o', label='Wolves')
alpha_scatter = ax.scatter(alpha_pos[0], alpha_pos[1], color='blue', marker='x', label='Alpha Wolf')
beta_scatter = ax.scatter(beta_pos[0], beta_pos[1], color='green', marker='x', label='Beta Wolf')
delta_scatter = ax.scatter(delta_pos[0], delta_pos[1], color='yellow', marker='x', label='Delta Wolf')

ax.set_title('F4 Contour and GWO Solution Space')
ax.set_xlabel('x1')
ax.set_ylabel('x2')
ax.legend()

# GWO Algorithm
def update(frame):
    global alpha_pos, beta_pos, delta_pos, alpha_score, beta_score, delta_score, wolves_pos

    for i in range(num_wolves):
        fitness = F4(wolves_pos[i])

        if fitness < alpha_score:
            alpha_score = fitness
            alpha_pos = wolves_pos[i].copy()

        elif fitness < beta_score:
            beta_score = fitness
            beta_pos = wolves_pos[i].copy()

        elif fitness < delta_score:
            delta_score = fitness
            delta_pos = wolves_pos[i].copy()

    a = 2 - frame * (2 / num_iterations)

    for i in range(num_wolves):
        for j in range(dim):
            r1 = np.random.rand()
            r2 = np.random.rand()
            A1 = 2 * a * r1 - a
            C1 = 2 * r2
            D_alpha = abs(C1 * alpha_pos[j] - wolves_pos[i][j])
            X1 = alpha_pos[j] - A1 * D_alpha

            r1 = np.random.rand()
            r2 = np.random.rand()
            A2 = 2 * a * r1 - a
            C2 = 2 * r2
            D_beta = abs(C2 * beta_pos[j] - wolves_pos[i][j])
            X2 = beta_pos[j] - A2 * D_beta

            r1 = np.random.rand()
            r2 = np.random.rand()
            A3 = 2 * a * r1 - a
            C3 = 2 * r2
            D_delta = abs(C3 * delta_pos[j] - wolves_pos[i][j])
            X3 = delta_pos[j] - A3 * D_delta

            wolves_pos[i][j] = (X1 + X2 + X3) / 3

        wolves_pos[i] = np.clip(wolves_pos[i], lb, ub)

    wolves_scatter.set_offsets(wolves_pos)
    alpha_scatter.set_offsets(alpha_pos)
    beta_scatter.set_offsets(beta_pos)
    delta_scatter.set_offsets(delta_pos)

    return wolves_scatter, alpha_scatter, beta_scatter, delta_scatter

anim = FuncAnimation(fig, update, frames=num_iterations, interval=300, repeat=False)

# Save animation as a GIF
anim_filename = 'gwo_animation.gif'
anim.save(anim_filename, writer='pillow', fps=15)

plt.show()

"""1. Plot Kontur F4 dan Ruang Solusi GWO:
Gambar ini menampilkan plot kontur dengan judul ‚ÄúF4 Contour and GWO Solution Space.‚Äù
Pada sumbu x, terdapat label x1 yang berkisar dari -20 hingga 20.
Pada sumbu y, terdapat label x2 dengan rentang yang serupa.
Garis kontur diisi dengan warna, menunjukkan berbagai tingkat fungsi F4. Warna bervariasi dari biru tua di tepi hingga kuning terang di tengah, mengindikasikan nilai fungsi yang semakin tinggi.

2. Terdapat empat jenis penanda:
Lingkaran merah dengan label ‚ÄúWolves‚Äù menunjukkan posisi serigala dalam algoritma optimisasi Grey Wolf Optimizer (GWO).
Silang biru dengan label ‚ÄúAlpha Wolf‚Äù menunjukkan posisi serigala alpha (solusi terbaik sejauh ini).
Silang hijau dengan label ‚ÄúBeta Wolf‚Äù menunjukkan posisi serigala beta (solusi kedua terbaik).
Silang ungu dengan label ‚ÄúDelta Wolf‚Äù menunjukkan posisi serigala delta (solusi ketiga terbaik).
Legenda di sudut kanan atas mencocokkan setiap warna penanda dengan labelnya.

3. Algoritma Grey Wolf Optimizer (GWO):
Algoritma ini berusaha mencari solusi optimal dalam ruang pencarian.
Serigala alpha, beta, dan delta mewakili solusi terbaik yang ditemukan sejauh ini.
Setiap iterasi, posisi serigala diperbarui berdasarkan aturan GWO.
Animasi menunjukkan bagaimana serigala bergerak menuju solusi yang lebih baik selama iterasi.

**ABC**

Artificial Bee Colony (ABC) adalah algoritma optimisasi yang terinspirasi oleh perilaku koloni lebah dalam mencari makanan

Parameter:

- Jumlah lebah (num_employed, num_onlookers): 7
- Iterasi (num_iterations): 80
- Rentang Solusi (Range): [-20, 20]
- Interval: 300 milidetik
- FPS (Frame Per Second): 15

Dengan parameter-parameter ini, kita akan mengimplementasikan dan memvisualisasikan bagaimana serigala-serigala tersebut menyesuaikan posisi mereka dalam ruang pencarian untuk fungsi ùêπ 4 ( ùë• ) = max ‚Å° ( ‚à£ ùë• 1 ‚à£ , ‚à£ ùë• 2 ‚à£ ) F4(x)=max(‚à£x 1‚Äã‚à£,‚à£x 2‚Äã‚à£).
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Define the F4 function
def F4(x):
    return np.max(np.abs(x))

# Define parameters
lb = -20  # lower bound
ub = 20   # upper bound
dim = 4   # dimension

# ABC parameters
num_employed = 7
num_onlookers = 7
num_iterations = 80

# Initialize bees' positions
employed_pos = lb + (ub - lb) * np.random.rand(num_employed, dim)
employed_scores = np.array([F4(pos) for pos in employed_pos])

# Initialize best position found
best_pos = employed_pos[np.argmin(employed_scores)].copy()
best_score = np.min(employed_scores)

# Initialize plot for the first two dimensions
fig, ax = plt.subplots()
ax.set_xlim((lb, ub))
ax.set_ylim((lb, ub))

# Create a grid of points for the first two dimensions
x1 = np.linspace(lb, ub, 200)
x2 = np.linspace(lb, ub, 200)
x1, x2 = np.meshgrid(x1, x2)
z = np.zeros_like(x1)
for i in range(x1.shape[0]):
    for j in range(x1.shape[1]):
        z[i, j] = F4(np.array([x1[i, j], x2[i, j], 0, 0]))  # Fixing last two dimensions to 0

contour = ax.contourf(x1, x2, z, levels=50, cmap='viridis')
cbar = fig.colorbar(contour)

employed_scatter = ax.scatter(employed_pos[:, 0], employed_pos[:, 1], color='red', marker='o', label='Employed Bees')
best_scatter = ax.scatter(best_pos[0], best_pos[1], color='blue', marker='x', label='Best Position')

ax.set_title('F4 Contour and ABC Solution Space (First Two Dimensions)')
ax.set_xlabel('x1')
ax.set_ylabel('x2')
ax.legend()

# ABC Algorithm
def update(frame):
    global employed_pos, employed_scores, best_pos, best_score

    # Employed bee phase
    for i in range(num_employed):
        new_position = employed_pos[i].copy()
        j = np.random.randint(dim)  # dimension to be changed

        phi = np.random.uniform(low=-1, high=1)
        k = np.random.randint(num_employed)
        while k == i:
            k = np.random.randint(num_employed)

        new_position[j] = employed_pos[i][j] + phi * (employed_pos[i][j] - employed_pos[k][j])
        new_position = np.clip(new_position, lb, ub)

        new_score = F4(new_position)
        if new_score < employed_scores[i]:
            employed_pos[i] = new_position
            employed_scores[i] = new_score

        # Update the best position found
        if new_score < best_score:
            best_pos = new_position
            best_score = new_score

    # Onlooker bee phase (using fitness proportionate selection)
    fitness = 1 / (1 + employed_scores)
    probs = fitness / fitness.sum()
    for _ in range(num_onlookers):
        i = np.random.choice(range(num_employed), p=probs)
        new_position = employed_pos[i].copy()
        j = np.random.randint(dim)  # dimension to be changed

        phi = np.random.uniform(low=-1, high=1)
        k = np.random.randint(num_employed)
        while k == i:
            k = np.random.randint(num_employed)

        new_position[j] = employed_pos[i][j] + phi * (employed_pos[i][j] - employed_pos[k][j])
        new_position = np.clip(new_position, lb, ub)

        new_score = F4(new_position)
        if new_score < employed_scores[i]:
            employed_pos[i] = new_position
            employed_scores[i] = new_score

        # Update the best position found
        if new_score < best_score:
            best_pos = new_position
            best_score = new_score

    # Scout bee phase (random search)
    for i in range(num_employed):
        if np.random.rand() < 0.1:  # 10% probability of scout bee phase
            employed_pos[i] = lb + (ub - lb) * np.random.rand(dim)
            employed_scores[i] = F4(employed_pos[i])

            # Update the best position found
            if employed_scores[i] < best_score:
                best_pos = employed_pos[i].copy()
                best_score = employed_scores[i]

    employed_scatter.set_offsets(employed_pos[:, :2])
    best_scatter.set_offsets(best_pos[:2])

    return employed_scatter, best_scatter

anim = FuncAnimation(fig, update, frames=num_iterations, interval=300, repeat=False)

# Save animation as a GIF
anim_filename = 'abc_animation_F4_dim4.gif'
anim.save(anim_filename, writer='pillow', fps=15)

plt.show()

"""1. Plot Kontur F4 dan Ruang Solusi ABC (Dua Dimensi Pertama):
- Gambar ini adalah plot kontur dua dimensi dengan judul ‚ÄúF4 Contour and ABC Solution Space (First Two Dimensions).‚Äù
- Pada sumbu x, terdapat label x1 yang berkisar dari -20 hingga 20.
- Pada sumbu y, terdapat label x2 dengan rentang yang serupa.
- Garis kontur diisi dengan warna, menunjukkan berbagai tingkat fungsi F4. Warna bervariasi dari biru tua di tepi hingga kuning terang di tengah, mengindikasikan nilai fungsi yang semakin tinggi.

- Terdapat beberapa titik yang ditandai pada plot:
a. Lingkaran merah dengan label ‚ÄúEmployed Bees‚Äù menunjukkan posisi lebah yang mungkin merupakan solusi dalam algoritma optimisasi ABC (Artificial Bee Colony).
b. Titik biru dengan tanda ‚ÄòX‚Äô menunjukkan posisi terbaik yang ditemukan oleh algoritma ABC.

- Skala warna di sebelah kanan menghubungkan warna dengan nilai numerik, berkisar sekitar 0 di tengah hingga lebih dari 19 di tepi.

Visualisasi ini terkait dengan algoritma optimisasi ABC, yang terinspirasi oleh perilaku koloni lebah dalam mencari makanan. Tujuannya adalah menemukan solusi optimal dalam ruang pencarian berdasarkan interaksi antara lebah pekerja (employed bees), lebah pengamat (onlooker bees), dan lebah penjelajah (scout bees). Dalam gambar ini, kita melihat bagaimana lebah pekerja bergerak menuju solusi yang lebih baik dalam mencari nilai minimum fungsi F4

**Hasil dan analisa**

1. Grey Wolf Optimizer (GWO)

  algoritma optimisasi yang terinspirasi oleh perilaku serigala abu-abu dalam mencari mangsa.
  Berikut adalah hasil dan analisis terkait GWO:

Hasil:

- GWO berusaha menemukan solusi optimal dalam ruang pencarian.

- Serigala alpha, beta, dan delta mewakili solusi terbaik yang ditemukan sejauh ini.

- Setiap iterasi, posisi serigala diperbarui berdasarkan aturan GWO.

- Animasi menunjukkan bagaimana serigala bergerak menuju solusi yang lebih baik selama iterasi.

Analisis:

- GWO memiliki konsep yang menarik dengan memodelkan perilaku serigala dalam kawanan.

- Algoritma ini efektif dalam mengoptimasi fungsi-fungsi kompleks dengan menggabungkan eksplorasi dan eksploitasi.

- Kelemahan GWO termasuk sensitivitas terhadap parameter dan kemungkinan terjebak dalam minimum lokal.


2. Artificial Bee Colony (ABC)
   adalah algoritma optimisasi yang terinspirasi oleh perilaku koloni lebah dalam mencari makanan. Berikut adalah hasil dan analisis terkait ABC:

Hasil:

- ABC berusaha menemukan solusi optimal dalam ruang pencarian.

- Lebah pekerja (employed bees) mencari solusi dengan menggantikan posisi secara acak.

- Lebah pengamat (onlooker bees) memilih solusi berdasarkan kualitasnya.

- Lebah penjelajah (scout bees) menggantikan solusi yang buruk.

- ABC memiliki potensi untuk menemukan solusi global.

Analisis:

ABC adalah algoritma sederhana dan efisien.
Kelebihan ABC termasuk kemampuan eksplorasi yang baik dan ketahanan terhadap minimum lokal.
Namun, ABC juga memiliki kekurangan, seperti sensitivitas terhadap parameter dan kecepatan konvergensi yang lambat.

**Kesimpulan**

Kedua algoritma ini memiliki pendekatan yang berbeda dalam mengoptimasi fungsi. GWO mengambil inspirasi dari perilaku serigala, sementara ABC mengambil inspirasi dari perilaku lebah. Pemilihan algoritma tergantung pada karakteristik masalah optimisasi dan preferensi pengguna.
"""